
#!/usr/bin/env python3

import rospy
import numpy as np
import math
from mavros_msgs.msg import State
from mavros_msgs.srv import CommandBool, SetMode
from geometry_msgs.msg import TwistStamped, PoseStamped
from std_msgs.msg import String

current_state = State()
theta = 0.0
beta = 0.0
zd = 3.0
current_pose = PoseStamped()
last_aruco_time = rospy.Time.now()
aruco_timeout = rospy.Duration(0.5)

# States
TAKEOFF = 0
FORMATION = 1
control_state = TAKEOFF

def state_cb(msg):
    global current_state
    current_state = msg

def aruco_cb(msg):
    global theta, beta, zd, last_aruco_time
    try:
        parts = msg.data.split(',')
        marker_id = int(parts[0])
        theta = math.radians(float(parts[1]))  # degrees to radians
        beta = math.radians(float(parts[2]))
        zd = float(parts[3])
        last_aruco_time = rospy.Time.now()  # update time
    except Exception as e:
        rospy.logwarn(f"Failed to parse /drone1/aruco_data: {e}")

def pose_cb(msg):
    global current_pose
    current_pose = msg

def distance_to_goal(goal):
    dx = current_pose.pose.position.x - goal[0]
    dy = current_pose.pose.position.y - goal[1]
    dz = current_pose.pose.position.z - goal[2]
    return math.sqrt(dx*dx + dy*dy + dz*dz)

def main():
    global control_state
    rospy.init_node("control_node_1", anonymous=True)

    # Subscribers
    rospy.Subscriber("/drone1/mavros1/state", State, state_cb)
    rospy.Subscriber("/drone1/aruco_data", String, aruco_cb)
    rospy.Subscriber("/drone1/mavros1/local_position/pose", PoseStamped, pose_cb)

    # Publishers
    vel_pub = rospy.Publisher("/drone1/mavros1/setpoint_velocity/cmd_vel", TwistStamped, queue_size=10)
    pos_pub = rospy.Publisher("/drone1/mavros1/setpoint_position/local", PoseStamped, queue_size=10)

    # Services
    rospy.wait_for_service("/drone1/mavros1/cmd/arming")
    rospy.wait_for_service("/drone1/mavros1/set_mode")
    arming_client = rospy.ServiceProxy("/drone1/mavros1/cmd/arming", CommandBool)
    set_mode_client = rospy.ServiceProxy("/drone1/mavros1/set_mode", SetMode)

    # Controller parameters
    l = 2
    c1 = 0.01
    c2 = 0.01
    h_star = 3  # desired height

    # Incidence matrix
    B = np.array([
        [1, 0, -1],
        [-1, 1, 0],
        [0, -1, 1]
    ])
    I2 = np.eye(2)
    B_bar = np.kron(B, I2)
    d = np.array([3, 3, 3])  # desired edge lengths

    takeoff_goal = [0.0, 0.0, 3.0]  # target point for takeoff
    pos_tolerance = 0.1  # meters

    rate = rospy.Rate(20)  # 20Hz

    while not rospy.is_shutdown() and not current_state.connected:
        rospy.loginfo_throttle(2, "[Drone1] Waiting for FCU connection...")
        rate.sleep()

    rospy.loginfo("[Drone1] FCU connected")

    # Send some dummy commands first
    pose_cmd = PoseStamped()
    pose_cmd.pose.position.x = takeoff_goal[0]
    pose_cmd.pose.position.y = takeoff_goal[1]
    pose_cmd.pose.position.z = takeoff_goal[2]

    for _ in range(100):
        pos_pub.publish(pose_cmd)
        rate.sleep()

    last_req = rospy.Time.now()

    while not rospy.is_shutdown():
        if current_state.mode != "OFFBOARD" and (rospy.Time.now() - last_req > rospy.Duration(5.0)):
            if set_mode_client(custom_mode="OFFBOARD").mode_sent:
                rospy.loginfo("[Drone1] OFFBOARD mode set")
            last_req = rospy.Time.now()

        elif not current_state.armed and (rospy.Time.now() - last_req > rospy.Duration(5.0)):
            if arming_client(True).success:
                rospy.loginfo("[Drone1] Drone armed")
            last_req = rospy.Time.now()

        if control_state == TAKEOFF:
            pos_pub.publish(pose_cmd)
            distance = distance_to_goal(takeoff_goal)

            if distance < pos_tolerance:
                rospy.loginfo("[Drone1] Takeoff completed, switching to formation control...")
                control_state = FORMATION

        elif control_state == FORMATION:
            # Formation control logic
            h = current_pose.pose.position.z

            if rospy.Time.now() - last_aruco_time < aruco_timeout:

                gamma = theta + beta

                z1 = -2 * math.sin(gamma) * zd * np.array([
                    math.cos(theta),
                    math.sin(theta)
                ])
                z2 = zd * np.array([
                    math.sin(beta),
                    -math.cos(beta)
                ])
                z3 = -z1 - z2

                z = np.concatenate((z1, z2, z3))
                z_matrix = z.reshape((3, 2))

                e = np.linalg.norm(z_matrix, axis=1)**l - d**l

                Dz = np.diag(z)
                Ek = np.column_stack((e, e)).flatten()

                p_dot = -c1 * np.matmul(B_bar, np.matmul(Dz, Ek))

                x_dot = p_dot[0]
                y_dot = p_dot[1]
            else:
                # No recent aruco data: stop x and y motion
                rospy.logwarn_throttle(2, "[Drone1] No recent aruco data, freezing XY!")
                x_dot = 0.0
                y_dot = 0.0

            # Control height (simple P)
            z_dot = c2 * (h_star - h)

            twist = TwistStamped()
            twist.twist.linear.x = x_dot
            twist.twist.linear.y = y_dot
            twist.twist.linear.z = z_dot

            vel_pub.publish(twist)

        rate.sleep()

if __name__ == "__main__":
    main()
