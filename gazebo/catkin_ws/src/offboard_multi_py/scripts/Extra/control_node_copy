#!/usr/bin/env python3

import rospy
import numpy as np
from mavros_msgs.msg import State
from mavros_msgs.srv import CommandBool, SetMode
from geometry_msgs.msg import TwistStamped, PoseStamped, Vector3Stamped
from std_msgs.msg import String
import tf
from tf.transformations import euler_from_quaternion

current_state = State()
# theta = 0.0
# beta = 0.5236
# zd = 3.0
# current_pose = None
# last_aruco_time = None
aruco_timeout = rospy.Duration(0.1)
aruco_ready = False
current_velocity = None

# States
TAKEOFF = 0
FORMATION = 1
control_state = TAKEOFF

def state_cb(msg):
    global current_state
    current_state = msg

def velocity_cb(msg):
    global current_velocity
    current_velocity = msg

class PID:
    def __init__(self, Kp, Ki, Kd, dt, output_limits=(None, None)):
        self.Kp = Kp
        self.Ki = Ki
        self.Kd = Kd
        self.dt = dt
        self.integral = 0.0
        self.prev_error = 0.0
        self.output_limits = output_limits

    def compute(self, error):
        self.integral += error * self.dt
        derivative = (error - self.prev_error) / self.dt
        output = self.Kp * error + self.Ki * self.integral + self.Kd * derivative
        self.prev_error = error

        lower, upper = self.output_limits
        if lower is not None:
            output = max(lower, output)
        if upper is not None:
            output = min(upper, output)

        return output


def aruco_cb(msg):
    global marker_id, theta, beta, zd, last_aruco_time, cx, cy, aruco_ready
    try:
        parts = msg.data.split(',')
        marker_id = int(parts[0])
        theta = np.radians(float(parts[1]))  # degrees to radians
        zd = float(parts[2])/1000
        cx = int(parts[3])
        cy = int(parts[4])
        last_aruco_time = rospy.Time.now()  # update time
        aruco_ready = True
    except Exception as e:
        rospy.logwarn(f"Failed to parse /drone1/aruco_data: {e}")

def pose_cb(msg):
    global current_pose
    current_pose = msg

def distance_to_goal(goal):
    dx = current_pose.pose.position.x - goal[0]
    dy = current_pose.pose.position.y - goal[1]
    dz = current_pose.pose.position.z - goal[2]
    return np.sqrt(dx*dx + dy*dy + dz*dz)

def main():
    global control_state
    rospy.init_node("control_node_1", anonymous=True)

    # Subscribers
    rospy.Subscriber("/drone1/mavros1/state", State, state_cb)
    rospy.Subscriber("/drone1/aruco_data", String, aruco_cb)
    rospy.Subscriber("/drone1/mavros1/local_position/pose", PoseStamped, pose_cb)
    rospy.Subscriber("/drone1/mavros1/local_position/velocity_local", TwistStamped, velocity_cb)

    # Publishers
    vel_pub = rospy.Publisher("/drone1/mavros1/setpoint_velocity/cmd_vel", TwistStamped, queue_size=10)
    pos_pub = rospy.Publisher("/drone1/mavros1/setpoint_position/local", PoseStamped, queue_size=10)
    error_pub = rospy.Publisher('error_vector', Vector3Stamped, queue_size=10)

    # Services
    rospy.wait_for_service("/drone1/mavros1/cmd/arming")
    rospy.wait_for_service("/drone1/mavros1/set_mode")
    arming_client = rospy.ServiceProxy("/drone1/mavros1/cmd/arming", CommandBool)
    set_mode_client = rospy.ServiceProxy("/drone1/mavros1/set_mode", SetMode)

    # Controller parameters
    l = 2
    c1 = 0.02
    c2 = 1
    c3 = 0.001
    h_star = 1.5  # desired height
    # yaw_star = -1.11 # desired yaw

    # Incidence matrix
    B = np.array([
        [1, 0, -1],
        [-1, 1, 0],
        [0, -1, 1]
    ])
    I2 = np.eye(2)
    B_bar = np.kron(B, I2)
    d = np.array([2, 2.69, 2.69])  # desired edge lengths

    takeoff_goal = [0.0, 0.0, h_star]  # target point for takeoff
    pos_tolerance = 0.1  # meters
    image_centre = 800/2
    rate = rospy.Rate(50)  # 20Hz

    z_pid = PID(Kp=1.0, Ki=0.1, Kd=0.2, dt=1.0/50, output_limits=(-1.0, 1.0))  # tune these

    while not rospy.is_shutdown() and not current_state.connected:
        rospy.loginfo_throttle(2, "[Drone1] Waiting for FCU connection...")
        rate.sleep()

    rospy.loginfo("[Drone1] FCU connected")

    # Send some dummy commands first
    pose_cmd = PoseStamped()
    pose_cmd.pose.position.x = takeoff_goal[0]
    pose_cmd.pose.position.y = takeoff_goal[1]
    pose_cmd.pose.position.z = takeoff_goal[2]
    # quat = tf.transformations.quaternion_from_euler(0, 0, yaw_star)
    # pose_cmd.pose.orientation.x = quat[0]
    # pose_cmd.pose.orientation.y = quat[1]
    # pose_cmd.pose.orientation.z = quat[2]
    # pose_cmd.pose.orientation.w = quat[3]

    for _ in range(100):
        pos_pub.publish(pose_cmd)
        rate.sleep()

    last_req = rospy.Time.now()

    while not rospy.is_shutdown():
        if current_state.mode != "OFFBOARD" and (rospy.Time.now() - last_req > rospy.Duration(5.0)):
            if set_mode_client(custom_mode="OFFBOARD").mode_sent:
                rospy.loginfo("[Drone1] OFFBOARD mode set")
            last_req = rospy.Time.now()

        elif not current_state.armed and (rospy.Time.now() - last_req > rospy.Duration(5.0)):
            if arming_client(True).success:
                rospy.loginfo("[Drone1] Drone armed")
            last_req = rospy.Time.now()
            
        if control_state == TAKEOFF:
            pos_pub.publish(pose_cmd)
            distance = distance_to_goal(takeoff_goal)

            if distance < pos_tolerance:
                rospy.loginfo("[Drone1] Takeoff completed, switching to formation control...")
                control_state = FORMATION

        elif control_state == FORMATION:
            # Formation control logic
            h = current_pose.pose.position.z
            x = current_pose.pose.position.x
            y = current_pose.pose.position.y

            if aruco_ready and ((rospy.Time.now() - last_aruco_time) < aruco_timeout):
                
                gamma = abs(theta)


                # z1 = np.array([-2*np.sin(gamma)**2*zd, 2*np.sin(gamma)*np.cos(gamma)*zd])

                q = current_pose.pose.orientation
                yaw = euler_from_quaternion([q.x, q.y, q.z, q.w])[2]
                vec_world = -np.array([x, y])
                z1 = np.dot([
                    [np.cos(yaw),  np.sin(yaw)],
                    [-np.sin(yaw), np.cos(yaw)]
                ], vec_world)

                # z3 = np.array([zd,0])
                vec_world = np.array([x, y]) - np.array([2.0, 1.0])  # vector from point a to drone
                z3 = np.dot([
                    [np.cos(yaw),  np.sin(yaw)],
                    [-np.sin(yaw), np.cos(yaw)]
                ], vec_world)
                # z2 = -z1 - z3
                z2 = np.array([0,0])

                z = np.concatenate((z1, z2, z3))
                z_matrix = z.reshape((3, 2))

                e = np.linalg.norm(z_matrix, axis=1)**l - d**l
                msg = Vector3Stamped()
                msg.header.stamp = rospy.Time.now()
                msg.vector.x = e[0]
                msg.vector.y = e[1]
                msg.vector.z = e[2]
                error_pub.publish(msg)

                Dz = np.diag(z)
                Ek = np.column_stack((e, e)).flatten()

                p_dot = -c1 * B_bar @ Dz @ Ek

                x_dot = p_dot[0]
                y_dot = p_dot[1]

                # Yaw control
                yaw_dot = c3 * (image_centre - cx)
                
            else:
                # No recent aruco data: stop x and y motion
                rospy.logwarn_throttle(5, "[Drone1] No marker detected")
                x_dot = 0.0
                y_dot = 0.0
                yaw_dot = 0

            # Velocity damping
            if current_velocity is not None:
                damping_gain = 0.5  # Tune this value as needed
                vx = current_velocity.twist.linear.x
                vy = current_velocity.twist.linear.y
                x_dot -= damping_gain * vx
                y_dot -= damping_gain * vy

            # Control height (simple P)
            z_dot = c2 * (h_star - h)
            # z_dot = z_pid.compute(h_star - h)

            
            # Send data to drone
            twist = TwistStamped()
            twist.twist.linear.x = x_dot
            twist.twist.linear.y = y_dot
            twist.twist.linear.z = z_dot
            twist.twist.angular.z = yaw_dot
            twist.twist.angular.x = 0
            twist.twist.angular.y = 0

            # rospy.loginfo(f"[Drone1] x_dot: {x_dot:.3f}, y_dot: {y_dot:.3f}")

            vel_pub.publish(twist)

        rate.sleep()

if __name__ == "__main__":
    main()
